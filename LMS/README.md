# LMS-система — развитие

## Постановка задачи

Вы продолжаете разрабатывать LMS-систему, начатую на прошлой неделе. Ваша задача — развить её функциональность, а также добавить средства автоматизации сборки и контейнеризацию.

## Описание задачи

Выполняется в последовательности, указанной ниже:

1. Создать Docker-файл для сборки приложения в Docker-образ.
2. Добавить CI для проекта, автоматизирующий сборку Docker-образа и прогон тестов.
3. Реализовать новые фичи в проект.

Каждой отдельной фиче должен соответствовать один мёрдж-реквест в dev. После мёрджа должна производиться автоматическая сборка Docker-образа для новой версии кода в master средствами CI.

### Создание Docker-файла

Docker-файл должен реализовывать два основных этапа:

- сборку приложения с помощью Gradle;
- запуск приложения с помощью JRE.

Используйте JRE-версии, аналогичные указанной в `build.gradle.kts`.

### Добавление CI

При создании мёрдж-реквеста необходимо:

- собрать приложение (через таск `build` Gradle);
- запустить тесты (через таск `check` Gradle).

При мёрдже в dev необходимо:

- собрать Docker-образ для новой версии приложения;
- запушить образ в Docker Registry.

## Описание новых фич

### Авторизация

В проекте прошлой недели вы реализовали авторизацию в достаточно примитивном виде. Теперь нужно сделать модель ближе к реальности: реализовать Basic-авторизацию по логину и паролю.

> Basic-авторизация редко используется для авторизации пользователей, обычно уступая таким технологиям, как JWT-токены. Однако это по-прежнему хороший вариант для сервисных учёток, общающихся с сервисом по https. 
>
> Мы выбрали Basic-авторизацию из-за простоты реализации.

Авторизация со стороны клиента должна происходить следующим образом: в заголовки запроса добавляется `Authorization` со значением `Basic Логин:Пароль`, где пара `Логин:Пароль` кодирована в `Base64`.

Пример:

```
login = den23421
password = test_pa$$word

// Хидер передаётся с HTTP-запросом
Authorization: ZGVuMjM0MjE6dGVzdF9wYSQkd29yZA==
```

Создай сущность `User`:

```text
User
- Id
- Login (not null)
- Password (not null)
- Role (STUDENT, MENTOR, ADMIN) (not null)
```

Реализуй сервис `AuthService`. Он будет проверять авторизацию пользователя по значению заголовка и в случае неуспеха выбрасывать исключение, которое должно трансформироваться в ошибку с 401-м статусом. В случае успешной авторизации сервис должен вернуть информацию о пользователе вызывающему коду.

Реализуй метод `/auth/signIn`, где администратор может регистрировать пользователей любых типов.

> **Ценителям ChatGPT и любопытным.** Не используйте Spring Security для реализации авторизации. Код во фреймворке сложный, и в нём легко запутаться. Логика Basic-авторизации, наоборот, достаточно проста для того, чтобы описать её руками небольшим количеством строк.

Предусмотри следующий сценарий: когда преподаватель регистрирует студента, то создаётся соответствующий пользователь с логином студента и с рандомно сгенерированным паролем. В качестве пароля можно использовать UUID. 

### Валидация данных и обработка исключений

В проекте предыдущей недели не было требований к валидации данных, данные отдавались в обёртке со статус-кодом в JSON. Измени подход:

- Добавь валидацию данных с помощью аннотаций javax.validation.
- В исключительных ситуациях (например, когда пытаются обновить сущность по несуществующему ID) необходимо выбрасывать пользовательское исключение. Напиши код в `ControllerAdvice` для обработки пользовательских исключений.

В случае ошибки должен отдаваться семантически корректный HTTP статус-код, а также JSON вида:

```json
{
    "errorCode": "error.code", 
    "errorMessage": "Описание ошибки"
}
```

Возвращай следующие HTTP-статусы:

```
OK — запрос прошёл успешно
CREATED — сущность создана
NO_CONTENT — сущность удалена
NOT_FOUND — сущность не найдена по ID
BAD_REQUEST — ошибка валидации
FORBIDDEN — ошибка прав доступа (студент пытается получить доступ к API препода)
```

Предусмотри следующую логику валидации:

```
Student
- Id
- Login (not null, max length = 30)
- FirstName (not null, max length = 100)
- LastName (not null, max length = 100)
- PhoneNumber 

Course
- Id
- Title (not null, max length = 100)
- Description (max length = 3000)

Topic
- Id
- Title (not null, max length = 100)
- Text (not null, max length = 3000)

Problem
- Id
- Title (not null, max length = 100)
- Description (not null, max length = 3000)
```

### Проверка прав доступа

Добавь во все контроллеры проверки прав доступа к эндпоинтам. Доставай из запроса хидер, с помощью авторизационного сервиса (который должен реализовать первый студент) получай текущую роль пользователя и производи необходимые проверки.

```text

Доступ только преподавателям и администраторам
- POST /students
- PATCH /students
- GET /students/{id} 
- DELETE /students/{id}
- POST /courses
- DELETE /courses/{id}
- POST /courses/{courseId}/enroll/{studentId}
- POST /courses/{courseId}/unenroll/{studentId}
- POST /courses/{id}/topics
- DELETE /topics/{id}
- POST /topics/{id}/problems
- DELETE /problems/{id}

Доступ всем пользователям (студентам, преподавателям и администраторам)
- GET /courses/{id}
- GET /courses/{id}
- GET /topics/{id}
- GET /problems/{id}
```

# Оценка

Выставляется как сумма оценок за каждый критерий.

- **Docker file**
  - 2 балла — полностью рабочее решение, собирается JAR с помощью Gradle из исходного кода, потом запускается с помощью JRE.
  - 1 балл — работает, но нет сборки с помощью Gradle, JAR прокидывается извне при сборке.
- **CI&CD**
  - 3 балла — реализован полностью пайплайн на MR в dev.
  - 2 балла — реализован полностью только один пайплайн.
  - 1 балл — пропущены стадии пайплайна (нет запуска тестов или сборки образа).
- **Фича с валидацией**
  - 2 балла — реализована полностью.
  - 1 балл — небольшие недочёты.
- **Фича с авторизацией и правами доступа**
  - 3 балла — полностью реализованная фича.
  - 2 балла — небольшие недочёты (к примеру, где-то не закрыли ручку пермишеном).
  - 1 балл — логика написана, но использовали GPT, пошли, к примеру, через Spring Security.
  - 0 баллов — баг в секьюрити, не работает проверка пароля, прочие критичные недочёты.


Максимальное количество баллов: 10.
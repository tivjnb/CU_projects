## **Описание проекта**

Необходимо спроектировать и реализовать REST API для маркетплейса. Проект должен обеспечить управление товарами и заказами, позволяя пользователям просматривать, добавлять товары, а также оформлять заказы.

**Функционал проекта**

1. **Управление товарами**
   - Пользователь может добавлять, редактировать и удалять товары, чтобы управлять каталогом товаров на маркетплейсе.
   - Пользователь может просматривать список товаров с фильтрами (категория, цена), чтобы быстро находить нужные товары.
2. **Создание заказа**
   - Пользователь может создавать заказ с выбранными товарами, чтобы оформить покупку.
   - Пользователь может видеть статус заказа (новый, в обработке, выполнен), чтобы отслеживать процесс выполнения заказа.
3. **Управление данными пользователей и товаров**
   - Все данные о пользователях, товарах и заказах хранятся в базе данных PostgreSQL.

## Хранение данных в PostgreSQL и **структура сущностей**

Для обеспечения надёжного хранения информации о пользователях, товарах и заказах в маркетплейсе используется база данных PostgreSQL. 

### Структура базы данных (сущностей)

**Основные таблицы проекта**

- **users** — хранит данные пользователей:
  - `id` (SERIAL PRIMARY KEY) — уникальный идентификатор пользователя.
  - `name` (VARCHAR) — имя пользователя.
  - `email` (VARCHAR UNIQUE) — адрес электронной почты (уникальное значение).
  - Дополнительные поля, например: `address`, `phone`.
- **products** — содержит информацию о товарах:
  - `id` (SERIAL PRIMARY KEY) — уникальный идентификатор товара.
  - `name` (VARCHAR) — название товара.
  - `description` (TEXT) — подробное описание.
  - `price` (DECIMAL) — стоимость товара.
  - `category` (VARCHAR) — категория товара.
- **orders** — хранит данные заказов:
  - `id` (SERIAL PRIMARY KEY) — уникальный идентификатор заказа.
  - `user_id` (INTEGER REFERENCES users(id)) — ссылка на пользователя, оформившего заказ.
  - `order_date` (TIMESTAMP) — дата и время заказа.
  - `status` (VARCHAR) — статус заказа (новый, в обработке, выполнен).
- **order_items** — описывает товары, включённые в заказ:
  - `id` (SERIAL PRIMARY KEY) — уникальный идентификатор записи.
  - `order_id` (INTEGER REFERENCES orders(id)) — ссылка на заказ.
  - `product_id` (INTEGER REFERENCES products(id)) — ссылка на товар.
  - `quantity` (INTEGER) — количество товара в заказе.
  - `price` (DECIMAL) — цена товара.

## Запуск проекта через Docker Compose

Для упрощения развёртывания и локальной разработки проект запускается с использованием Docker Compose. Это позволяет одновременно поднять контейнер с приложением и контейнер с PostgreSQL.

### Пример файла `docker-compose.yml`

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:14  # Используем официальный образ PostgreSQL версии 14
    container_name: postgres_container
    restart: always
    environment:
      POSTGRES_USER: myuser       # Имя пользователя для базы данных
      POSTGRES_PASSWORD: mypassword  # Пароль пользователя
      POSTGRES_DB: mydatabase     # Название базы данных
    ports:
      - "5432:5432"  # Проброс порта для доступа к PostgreSQL локально
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Храним данные PostgreSQL в volume

  pgadmin:
    image: dpage/pgadmin4  # Используем официальный образ PgAdmin
    container_name: pgadmin_container
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com  # Email для входа в PgAdmin
      PGADMIN_DEFAULT_PASSWORD: adminpassword   # Пароль для входа в PgAdmin
    ports:
      - "5050:80"  # Проброс порта для доступа к PgAdmin локально
    depends_on:
      - postgres  # PgAdmin будет запускаться только после того, как запустится PostgreSQL

volumes:
  postgres_data:  # Объявляем volume для хранения данных PostgreSQL
```

## **CI: автоматизация процессов**

Для проекта должна быть настроена система CI, которая автоматически выполняет запуск тестов. Это поможет убедиться в том, что API работает корректно.

### Пример настройки CI для GitLab CI — файл `.gitlab-ci.yml`

<details>
  <summary>Python</summary>

```yaml
stages:
  - test

variables:
  DATABASE_URL: "postgresql://myuser:mypassword@postgres:5432/mydatabase"

test:
  stage: test
  image: python:3.11
  tags:
    - students-buildkit-medium
  services:
    - postgres:14
  before_script:
    - pip install -r requirements.txt
    - export PGPASSWORD=mypassword
    - psql -h postgres -U myuser -c "CREATE DATABASE mydatabase;"
  script:
    - python -m unittest discover
```
- **stages:** определён один этап — `test`.
- **variables:** устанавливается переменная окружения `DATABASE_URL` для подключения к базе.
- **image:** используется образ Python 3.11.
- **services:** добавляется сервис PostgreSQL версии 14.
- **before_script:** 
  - устанавливаются зависимости из `requirements.txt`;
  - экспортируется переменная `PGPASSWORD` для аутентификации PostgreSQL;
  - создаётся база данных с помощью команды `psql`.
- **script:** запускаются тесты с помощью встроенного модуля `unittest` (`python -m unittest discover`).

</details>

<details>
  <summary>Java</summary>

```yaml
stages:
  - test

variables:
  DATABASE_URL: "postgresql://myuser:mypassword@postgres:5432/mydatabase"

test:
  stage: test
  image: gradle:8.12.1-jdk17
  tags:
    - students-buildkit-medium
  services:
    - postgres:14
  before_script:
    - export PGPASSWORD=mypassword
    - psql -h postgres -U myuser -c "CREATE DATABASE mydatabase;"
  script:
    - gradle test --info
  artifacts:
    paths:
      - build/test-results/
      - build/reports/
    when: always
  cache:
    paths:
      - .gradle/
```
- **stages:** определён один этап — `test`.
- **variables:** устанавливается переменная окружения `DATABASE_URL` для подключения к базе.
- **image:** используется образ Gradle.
- **services:** добавляется сервис PostgreSQL версии 14.
- **before_script:** 
  - экспортируется переменная `PGPASSWORD` для аутентификации PostgreSQL;
  - создаётся база данных с помощью команды `psql`.
- **script:** запускаются тесты с помощью `gradle` (`gradle test --info`).

</details>

## **Порядок реализации проекта**

1. Создайте структуру базы данных в PostgreSQL.
2. Разработайте бизнес-логику обработки данных и проверок.
3. Реализуйте REST API с использованием Flask.
4. Напишите unit-тесты для проверки API.
5. Настройте тестирование через CI.
6. Задокументируйте API с использованием Swagger.
7. Настройте Docker Compose для запуска приложения и базы данных.

## Распределение задач между разработчиками

Каждый разработчик отвечает за свою фичу **целиком**. Это значит, что он разрабатывает:

**1) структуру данных** — создаёт соответствующие таблицы в PostgreSQL;

**2) бизнес-логику** — реализует правила обработки данных и проверок;

**3) API** — разрабатывает REST API на Flask для работы с фичей;

**4) тесты** — пишет unit-тесты для проверки работы API.

## **Система оценивания**

### Оценка по критериям

1. **Реализация бизнес-логики и функционала: 2 балла**
   - **2 балла** — полная и корректная реализация всех требуемых функций, таких как создание, редактирование и удаление товаров, создание заказов, управление пользователями, с учётом бизнес-логики (например, правильные проверки данных и обработка ошибок).
   - **1 балл** — реализовано большинство функций, но имеются недочёты в обработке данных или некоторых аспектах бизнес-логики.
   - **0 баллов** — бизнес-логика не реализована или реализована с критичными ошибками.
2. **Проектирование и структура базы данных: 2 балла**
   - **2 балла** — структура базы данных логична, нормализована, связи между таблицами правильно настроены.
   - **1 балл** — структура базы данных есть, но имеет недостатки, такие как избыточность данных или неудачные связи.
   - **0 баллов** — структура базы данных нарушает основные принципы нормализации либо отсутствует.
3. **Реализация REST API: 2 балла**
   - **2 балла** — полная реализация всех требуемых методов с правильной обработкой ошибок и валидацией данных. API соответствует стандартам REST.
   - **1 балл** — реализация более 50% методов с некоторыми недостатками (например, не все методы или неправильная обработка ошибок).
   - **0 баллов** — API не реализовано или реализовано с грубыми ошибками.
4. **Документирование API с использованием Swagger: 1 балл**
   - **1 балл** — полное документирование API с использованием Swagger, доступна информация о каждом эндпоинте и параметрах.
   - **0 баллов** — документация либо отсутствует, либо крайне недостаточна.
5. **Тестирование: 1 балл**
   - **1 балл** — написаны unit-тесты для всех основных функций API, тестируются все критичные пути.
   - **0 баллов** — тесты либо отсутствуют, либо покрывают только часть функционала.
6. **Docker Compose и развёртывание проекта: 2 балла**
   - **2 балла** — проект корректно работает с Docker Compose, контейнеры приложения и базы данных PostgreSQL запускаются без ошибок, правильно настроены зависимости, порты и volumes. Инструкция по запуску проста и понятна.
   - **1 балл** — проект работает с Docker Compose, но есть проблемы с настройкой контейнеров или зависимостей, требуют дополнительных настроек для корректного запуска.
   - **0 баллов** — Docker Compose не настроен или проект не работает.

### Итоговая оценка

- **10 баллов (отлично)** — проект полностью завершён, все требования выполнены на высоком уровне, API корректно работает с базой данных и бизнес-логикой, документация полная, тестирование проведено для всех функций, проект корректно развёрнут с использованием Docker Compose.
- **7–9 баллов (хорошо)** — проект имеет несколько недочётов в реализации (например, частичная реализация бизнес-логики или API), но в целом работает корректно, Docker Compose настроен с небольшими проблемами.
- **5–6 баллов (удовлетворительно)** — реализована основная часть функционала, но есть ошибки или недочёты в бизнес-логике, API, тестах или настройке Docker Compose.
- **1–4 балла (неудовлетворительно)** — значительные ошибки в проекте, не реализованы важные функции или проект не выполняет требования.
- **0 баллов** — проект не сдан или не работает.
